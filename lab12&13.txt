10 11
 **Flask + Kubernetes**.

* **3Ô∏è‚É£ Manual / On-demand pipeline ‚Üí FULL clear steps**
* **4Ô∏è‚É£ Cron-based automated pipeline ‚Üí ONLY changes**
* Use **Flask instead of Java/Maven**
* Simple, stable, exam-safe (no fancy stuff)

---

# ‚úÖ 3. Flask + Kubernetes

## Manual / On-Demand CI/CD Pipeline

---

## üîπ What this pipeline does

You **manually click ‚ÄúBuild Now‚Äù** in Jenkins.

Jenkins will:

1. Pull Flask code from GitHub
2. Build a Docker image
3. Containerize the Flask app
4. Deploy it to a **Kubernetes cluster**

---

## STEP 1: Install required tools (Linux)

```bash
sudo apt update
sudo apt install -y git docker.io python3 python3-pip jenkins kubectl minikube
```

Docker permissions:

```bash
sudo usermod -aG docker $USER
sudo usermod -aG docker jenkins
newgrp docker
sudo systemctl restart jenkins
```

---

## STEP 2: Start Kubernetes (Minikube)

```bash
minikube start --driver=docker
```

Verify:

```bash
kubectl get nodes
```

---

## STEP 3: Create a simple Flask application

```bash
mkdir flask-k8s
cd flask-k8s
```

### `app.py`

```python
from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello from Flask Kubernetes CI/CD Pipeline"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
```

### `requirements.txt`

```text
flask
```

Test locally:

```bash
pip3 install flask
python3 app.py
```

Open:

```
http://localhost:5000
```

Stop with **Ctrl + C**

---

## STEP 4: Dockerfile (Flask)

### `Dockerfile`

```dockerfile
FROM python:3.10-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY app.py .
EXPOSE 5000
CMD ["python", "app.py"]
```

---

## STEP 5: Kubernetes deployment file

### `deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: flask-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: flask-app
  template:
    metadata:
      labels:
        app: flask-app
    spec:
      containers:
      - name: flask-app
        image: flask-k8s-app
        imagePullPolicy: Never
        ports:
        - containerPort: 5000
```

### `service.yaml`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: flask-service
spec:
  type: NodePort
  selector:
    app: flask-app
  ports:
    - port: 5000
      targetPort: 5000
```

---

## STEP 6: Push code to GitHub

```bash
git init
git add .
git commit -m "Flask Kubernetes manual pipeline"
git branch -M main
git remote add origin https://github.com/<your-username>/flask-k8s.git
git push -u origin main
```

---

## STEP 7: Jenkinsfile (Manual / On-Demand)

### `Jenkinsfile`

```groovy
pipeline {
    agent any

    stages {
        stage('Clone') {
            steps {
                git 'https://github.com/<your-username>/flask-k8s.git'
            }
        }

        stage('Docker Build') {
            steps {
                sh 'docker build -t flask-k8s-app .'
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                sh 'kubectl apply -f deployment.yaml'
                sh 'kubectl apply -f service.yaml'
            }
        }
    }
}
```

---

## STEP 8: Create Jenkins Job

1. Jenkins ‚Üí **New Item**
2. Name: `flask-k8s-manual`
3. Type: **Pipeline**
4. Pipeline script from SCM ‚Üí Git
5. Repo URL ‚Üí GitHub repo
6. Script path ‚Üí `Jenkinsfile`
7. Save
8. Click **Build Now**

---

## STEP 9: Verify deployment

```bash
kubectl get pods
kubectl get svc
```

Access application:

```bash
minikube service flask-service
```

You should see:

```
Hello from Flask Kubernetes CI/CD Pipeline
```

---

## üîç Pipeline Stage Explanation (Manual)

| Stage        | Explanation                          |
| ------------ | ------------------------------------ |
| Clone        | Jenkins pulls Flask code from GitHub |
| Docker Build | Docker image is created              |
| Deploy       | Flask app deployed to Kubernetes     |

---

# ‚úÖ 4. Flask + Kubernetes

## Cron-Based Automated CI/CD Pipeline

(**ONLY changes needed**)

‚úî **Steps remain exactly the same as Pipeline 3**

---

## üîÅ Change 1: Add cron trigger in Jenkinsfile

### Updated `Jenkinsfile` (only change)

```groovy
pipeline {
    agent any

    triggers {
        cron('H/5 * * * *')
    }

    stages {
        stage('Clone') {
            steps {
                git 'https://github.com/<your-username>/flask-k8s.git'
            }
        }

        stage('Docker Build') {
            steps {
                sh 'docker build -t flask-k8s-app .'
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                sh 'kubectl apply -f deployment.yaml'
                sh 'kubectl apply -f service.yaml'
            }
        }
    }
}
```

---

## üîÅ What changed?

| Manual Pipeline | Cron-Based Pipeline |
| --------------- | ------------------- |
| Build Now       | Automatic execution |
| User-triggered  | Time-triggered      |
| On-demand       | Fully automated     |

### Cron expression:

```
H/5 * * * *
```

‚û° Runs **every 5 minutes automatically**

---

## üîç Automated Pipeline Stage Explanation

| Stage  | Explanation                                 |
| ------ | ------------------------------------------- |
| Clone  | Code pulled automatically                   |
| Build  | Docker image built automatically            |
| Deploy | Kubernetes deployment updated automatically |

---

## ‚úÖ Final Exam-Ready Summary

> In the manual pipeline, Jenkins executes the CI/CD process only when triggered by the user. In the cron-based automated pipeline, Jenkins uses scheduled cron jobs to automatically build, containerize, and deploy the Flask application to a Kubernetes cluster without manual intervention.


